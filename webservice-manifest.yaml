Для веб-приложения использовал простой Hello-World написанный на Go (hello.go) и сервер nginx.
Для доступа к веб-приложению используется Service  с типом loadbalancer
Мультизональный отказоустойчивый кластер подразумевает, что на каждой зоне должен быть экземпляр сервиса.
Допустим есть зоны А(2 ноды), Б(2 ноды) и В(1 нода), и в зоне В умирает нода, деплоймент должен развернуть новую ноду именно в зоне В. 
За это отвечает PodAntiAffinity с параметром requiredDuringSchedulingIgnoredDuringExecution ("жестко" разнести оп узлам) 



apiVersion: apps/v1
kind: Deployment            
metadata:               
  name: myservice        имя сервиса
spec:
  replicas: 5            количество реплик сервиса
  selector:
    matchLabels:
      appname: web       метка по которым будем следить за количеством реплик
  template:              шаблон
    metadata:
      name: nginx
      labels:
        appname: web
  spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - web
            topologyKey: "kubernetes.io/hostname"
      containers:
      - name: nginx              
        image: nginx:latest             установка nginx
        volumeMounts:                       
        - name: config-nginx                подключение configmap
          mountPath: /etc/nginx/conf.d/     вот по этому пути
      - name: site                        
        image: containous/site              запуск второго образа hello.go
      volumes:
      - name: config-nginx                  отсюда берет данные которые подключаются Mountpath
        configMap:
           name: nginx-config

apiVersion: v1
kind: service
metadata:
  name: nginx-service
spec: 
  selector:
    appname: web
  ports:
      - protocol: TCP
        port: 80 
        targetPort: 80
  type: loadBalancer      

apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: myservice
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myservice
  minReplicas: 3
  maxReplicas: 5
  targetCPUUtilizationPercentage: 70

apiVersion: v1  
kind: ResourceQuota  
metadata:  
  name: quota  
spec:  
  hard:
    limits.cpu: "4"  
    limits.memory: 1Gi
